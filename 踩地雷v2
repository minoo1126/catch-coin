import random
from enum import Enum
import os
import time
import pygame
import sys
from pygame.locals import *

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
RES_DIR = os.path.join(BASE_DIR, 'resources')

width = 25
height = 12
# 這個size是指方格大小與非控制台區域大小
# ------------------------------
# |         😊 ← 笑臉按鈕         |   ← face_pos_x, face_pos_y
# |------------------------------|
# | [ ] [ ] [ ] [ ] [ ] [ ] ... |   ← 地雷區
# | [ ] [ ] [ ] [ ] [ ] [ ] ... |
size = 25
bomb_count = 50
screen_width = width * size
screen_height = (height + 2) * size  # +2 是為上方笑臉區域留空

class BoardStatus(Enum):
    cover = 0    # 未揭開
    reveal = 1   # 已揭開
    mine = 3     # 地雷（不直接用）
    flag = 4     # 標記為地雷旗
    ask = 5      # 問號標記
    bomb = 6     # 踩到地雷的狀態
    hint = 7     # 雙擊提示格子
    double = 8   # 雙擊中狀態

class Mine:
    def __init__(self, x, y, value=0):
        self.x = x
        self.y = y
        self._value = 0  # 私有變數，代表是否是地雷
        self.around_count = -1  # 周圍地雷數，-1 表示尚未計算
        self.status = BoardStatus.cover  # 初始狀態為覆蓋
        self.value = value  # 使用 property 設定地雷或非地雷

    # property getter
    def get_value(self):
        return self._value

    # property setter
    def set_value(self, value):
        if value:
            self._value = 1
        else:
            self._value = 0

    value = property(fget=get_value, fset=set_value, doc='0:非地雷 1:地雷')

class MineBlock:
    def __init__(self, width, height, mine_count):
        self.width = width
        self.height = height
        self.mine_count = mine_count
        
        # 建立空地雷地圖，全部非地雷
        self.block = [[Mine(x, y) for x in range(width)] for y in range(height)]

        # 所有座標列表
        position = [(x, y) for y in range(height) for x in range(width)]
        random.shuffle(position)  # 打亂順序

        # 取前 mine_count 個座標放置地雷
        for x, y in position[:mine_count]:
            self.block[y][x].value = 1

    def getmine(self, x, y):
        return self.block[y][x]

    def open_mine(self, x, y):
        # 如果踩到地雷，設定狀態並回傳 False 表示遊戲結束
        if self.block[y][x].value:
            self.block[y][x].status = BoardStatus.bomb
            return False

        # 非地雷，揭開格子
        self.block[y][x].status = BoardStatus.reveal

        around = get_around(x, y)

        # 計算周圍地雷數
        sum = 0
        for i, j in around:
            if self.block[j][i].value:
                sum += 1
        self.block[y][x].around_count = sum

        # 如果周圍沒有地雷，遞迴揭開鄰近格子
        if sum == 0:
            for i, j in around:
                if self.block[j][i].around_count == -1:
                    self.open_mine(i, j)

        return True

    def double_mouse_button_down(self, x, y):
        # 周圍無雷時，雙擊不執行其他動作，直接回傳 True
        if self.block[y][x].around_count == 0:
            return True

        self.block[y][x].status = BoardStatus.double
        around = get_around(x, y)
        sumflag = 0

        # 計算周圍標記旗子的數量
        for i, j in around:
            if self.block[j][i].status == BoardStatus.flag:
                sumflag += 1

        # 若旗子數等於周圍地雷數，嘗試打開周圍其他格子
        if sumflag == self.block[y][x].around_count:
            for i, j in around:
                if self.block[j][i].status == BoardStatus.cover:
                    if not self.open_mine(i, j):
                        return False
        else:
            # 旗子數不符時，將未標記的周圍格子標示提示狀態
            for i, j in around:
                if self.block[j][i].status == BoardStatus.cover:
                    self.block[j][i].status = BoardStatus.hint

        return True

    def double_mouse_button_up(self, x, y):
        self.block[y][x].status = BoardStatus.reveal
        for i, j in get_around(x, y):
            if self.block[j][i].status == BoardStatus.hint:
                self.block[j][i].status = BoardStatus.cover

class GameStatus(Enum):
    readied = 1
    start = 2
    over = 3
    win = 4

def print_text(screen, font, x, y, text, fcolor=(255, 255, 255)):
    imgText = font.render(text, True, fcolor)
    screen.blit(imgText, (x, y))

def load_image(name, size):
    path = os.path.join(RES_DIR, name)
    if os.path.exists(path):
        img = pygame.image.load(path).convert()
        img = pygame.transform.smoothscale(img, (size, size))
    else:
        print(f"Warning {name} not found in resources, please try again")
        img = pygame.Surface((size, size))
        img.fill((200, 200, 200))
    return img

def get_around(x, y):
    around = []
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx == 0 and dy == 0:
                continue
            nx, ny = x + dx, y + dy
            if 0 <= nx < width and 0 <= ny < height:
                around.append((nx, ny))
    return around

def main():
    pygame.init()
    screen = pygame.display.set_mode((screen_width, screen_height))
    pygame.display.set_caption('踩地雷')

    font = pygame.font.Font(os.path.join(RES_DIR, 'a.TTF'), size * 2)
    fwidth, fheight = font.size('999')
    red = (200, 40, 40)

    # 載入圖片
    img0 = load_image('0.bmp', size)
    img1 = load_image('1.bmp', size)
    img2 = load_image('2.bmp', size)
    img3 = load_image('3.bmp', size)
    img4 = load_image('4.bmp', size)
    img5 = load_image('5.bmp', size)
    img6 = load_image('6.bmp', size)
    img7 = load_image('7.bmp', size)
    img8 = load_image('8.bmp', size)
    img_ask = load_image('ask.bmp', size)
    img_blank = load_image('blank.bmp', size)
    img_blood = load_image('blood.bmp', size)
    img_error = load_image('error.bmp', size)
    img_face_fall = load_image('face_fall.bmp', size)
    img_face_normal = load_image('face_normal.bmp', size)
    img_face_success = load_image('face_success.bmp', size)  # 改成勝利臉圖
    img_mine = load_image('mine.bmp', size)
    img_flag = load_image('flag.bmp', size)

    face_pos_x = (screen_width - size) // 2
    face_pos_y = size // 2

    img_dict = {
        0: img0,
        1: img1,
        2: img2,
        3: img3,
        4: img4,
        5: img5,
        6: img6,
        7: img7,
        8: img8
    }

    bgcolor = (225, 225, 225)
    block = MineBlock(width, height, bomb_count)
    game_status = GameStatus.readied
    start_time = None
    elapsed_time = 0

    running = True

    while running:
        screen.fill(bgcolor)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_x, mouse_y = event.pos
                x = mouse_x // size
                y = mouse_y // size - 2
                b1, b2, b3 = pygame.mouse.get_pressed()
                if game_status == GameStatus.start:
                    if b1 and b3:
                        mine = block.getmine(x, y)
                        if mine.status == BoardStatus.reveal:
                            if not block.double_mouse_button_down(x, y):
                                game_status = GameStatus.over
            elif event.type == pygame.MOUSEBUTTONUP:
                mouse_x, mouse_y = event.pos
                x = mouse_x // size
                y = mouse_y // size - 2
                if y < 0:
                    # 笑臉按鈕區域點擊
                    if face_pos_x <= mouse_x <= face_pos_x + size and face_pos_y <= mouse_y <= face_pos_y + size:
                        game_status = GameStatus.readied
                        block = MineBlock(width, height, bomb_count)
                        start_time = time.time()
                        elapsed_time = 0
                    continue
                
                if game_status == GameStatus.readied:
                    game_status = GameStatus.start
                    start_time = time.time()
                    elapsed_time = 0
                
                if game_status == GameStatus.start:
                    mine = block.getmine(x, y)
                    b1, b2, b3 = pygame.mouse.get_pressed()
                    if b1 and not b3:
                        if mine.status == BoardStatus.cover:
                            if not block.open_mine(x, y):
                                game_status = GameStatus.over
                    elif not b1 and b3:
                        if mine.status == BoardStatus.cover:
                            mine.status = BoardStatus.flag
                        elif mine.status == BoardStatus.flag:
                            mine.status = BoardStatus.ask
                    elif b1 and b3:
                        if mine.status == BoardStatus.double:
                            block.double_mouse_button_up(x, y)

        flag_count = 0
        opened_count = 0

        for row in block.block:
            for mine in row:
                pos = (mine.x * size, (mine.y + 2) * size)

                if mine.status == BoardStatus.reveal:
                    screen.blit(img_dict[mine.around_count], pos)
                    opened_count += 1
                elif mine.status == BoardStatus.double:
                    screen.blit(img_dict[mine.around_count], pos)
                elif mine.status == BoardStatus.bomb:
                    screen.blit(img_blood, pos)
                elif mine.status == BoardStatus.flag:
                    screen.blit(img_flag, pos)
                    flag_count += 1
                elif mine.status == BoardStatus.ask:
                    screen.blit(img_ask, pos)
                elif mine.status == BoardStatus.hint:
                    screen.blit(img0, pos)
                elif game_status == GameStatus.over and mine.value:
                    screen.blit(img_mine, pos)
                elif mine.value == 0 and mine.status == BoardStatus.flag:
                    screen.blit(img_error, pos)
                elif mine.status == BoardStatus.cover:
                    screen.blit(img_blank, pos)

        # 顯示剩餘地雷數（總地雷 - 旗子數）
        print_text(screen, font, 30, (size * 2 - fheight) // 2 - 2, '%02d' % (bomb_count - flag_count), red)

        if game_status == GameStatus.start:
            elapsed_time = int(time.time() - start_time)
        print_text(screen, font, screen_width - fwidth - 30, (size * 2 - fheight) // 2 - 2, '%03d' % elapsed_time, red)

        # 判斷是否贏得遊戲（旗子+已開啟數量等於全部格子數）
        if flag_count + opened_count == width * height:
            game_status = GameStatus.win

        if game_status == GameStatus.over:
            screen.blit(img_face_fall, (face_pos_x, face_pos_y))
        elif game_status == GameStatus.win:
            screen.blit(img_face_success, (face_pos_x, face_pos_y))
        else:
            screen.blit(img_face_normal, (face_pos_x, face_pos_y))

        pygame.display.update()

if __name__ == '__main__':
    main()
